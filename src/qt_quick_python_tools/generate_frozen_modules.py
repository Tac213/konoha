"""
Script for generating frozen module headers
"""

import sys
import os
import re
import types
import typing
import enum
import importlib
from importlib import machinery, util
import modulefinder
import dataclasses
import subprocess
import shutil

# ROOT_DIR = os.path.normpath(os.path.join(__file__, "..", "..", ".."))
ROOT_DIR = os.getcwd()
FROZEN_MODULE_DIR = os.path.join(ROOT_DIR, "src", "frozen_modules")
if not os.path.exists(FROZEN_MODULE_DIR):
    os.makedirs(FROZEN_MODULE_DIR)

# See: ${CPYTHON_SRC}/Python/frozen.c
OFFICIAL_FROZEN_MODULE_NAMES = (
    "_frozen_importlib",
    "_frozen_importlib_external",
    "zipimport",
    "abc",
    "codecs",
    "io",
    "_collections_abc",
    "_sitebuiltins",
    "genericpath",
    "ntpath",
    "posixpath",
    "os.path",
    "os",
    "site",
    "stat",
    "importlib.util",
    "importlib.machinery",
    "runpy",
    # alias
    "importlib._bootstrap",
    "importlib._bootstrap_external",
)

FROZEN_MODULES_HEADER = os.path.join(FROZEN_MODULE_DIR, "frozen_modules.h")
FROZEN_MODULES_HEADER_SRC = """\
// Generated by: generate_frozen_modules
#include "Python.h"
{frozen_headers}

static struct _frozen _PyImport_FrozenModules[] = {{
{module_infos}
    {{0, 0, 0}}  /* sentinel */
}};
"""


@dataclasses.dataclass
class ModuleInfo:
    """
    Data class of module info
    """

    module_name: str
    module: types.ModuleType
    is_package: bool
    origin: str


@dataclasses.dataclass
class ModuleAnalysisInfo:
    """
    Data class of module analysis info
    """

    entry_module_name: str  # A python module name or a signle python_file
    hidden_imports: list[str]  # hidden import module names
    excludes: list[str]  # exclude module names


class ModuleType(enum.IntFlag):
    """
    Module type enum
    """

    SOURCE_MODULE = enum.auto()
    BYTECODE_MODULE = enum.auto()
    EXTENSION_MODULE = enum.auto()


def get_list_arg(arg_str: str, arg_name: str = "") -> typing.List[str]:
    """
    Get command line list arg
    Args:
        arg_str: raw command line string
        arg_name: expected arg name
    Returns:
        list
    """
    argname, _, args = arg_str.partition("=")
    if arg_name and arg_name != argname:
        usage(f"Incorrect arg name: {argname}, expected: {arg_name}")
    list_args = re.split(r"\s?,\s?", args)
    while "" in list_args:
        list_args.remove("")
    return list_args


def get_python_bootstrap_module_names() -> typing.List[str]:
    """
    Get python bootstrap module names
    Returns:
        list
    """
    with subprocess.Popen(
        f'{sys.executable} -c "import sys; print(list(sys.modules.keys()))"', shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE
    ) as p:
        p.wait()
        stdout, stderr = p.communicate()
        if p.returncode:
            usage(f"Could not get python bootstrap modules, {str(stderr, 'utf-8')}")
        bootstrap_module_names: typing.List[str] = eval(stdout)  # pylint: disable=eval-used
    if "__main__" in bootstrap_module_names:
        bootstrap_module_names.remove("__main__")
    for official_frozen_module_name in OFFICIAL_FROZEN_MODULE_NAMES:
        if official_frozen_module_name in bootstrap_module_names:
            bootstrap_module_names.remove(official_frozen_module_name)
    editable_finder_name = None
    for name in bootstrap_module_names:
        if name.startswith("__editable__"):
            editable_finder_name = name
            break
    if editable_finder_name is not None:
        bootstrap_module_names.remove(editable_finder_name)
    return bootstrap_module_names


def clear_frozen_module_dir() -> None:
    """
    Clear frozen module dir
    Returns:
        None
    """
    if os.path.isdir(FROZEN_MODULE_DIR):
        shutil.rmtree(FROZEN_MODULE_DIR)
    os.makedirs(FROZEN_MODULE_DIR)


def is_package(module: types.ModuleType) -> bool:
    """
    Return True if the module is a package.
    Args:
        module
    Returns:
        bool
    """
    module_path = module.__spec__.origin
    file_name = os.path.split(module_path)[1]
    return any(file_name == "__init__" + suffix for suffix in machinery.SOURCE_SUFFIXES)


def create_module(fullname: str) -> types.ModuleType:
    """
    Create a module object but do not exec it
    Only external modules (.py .pyc .pyd .pyw) will be found
    Args:
        fullname: module fullname
    Returns:
        module object
    """
    if fullname in sys.modules:
        return sys.modules[fullname]
    path_list = None
    parent_module_name = fullname.rpartition(".")[0]
    if parent_module_name:
        parent_module = create_module(parent_module_name)
        path_list = parent_module.__path__
    spec = None
    for finder in sys.meta_path:
        if finder in (machinery.BuiltinImporter, machinery.FrozenImporter):
            continue
        spec = finder.find_spec(fullname, path_list)
        if spec:
            break
    if spec is None:
        raise ModuleNotFoundError(f"No module named {fullname}", name=fullname)
    module = util.module_from_spec(spec)
    return module


def get_module_info(module_name: str, is_entry_module: bool = False) -> ModuleInfo:
    """
    Get module info by module name
    Args:
        module_name: A python module name or a single python_file
        is_entry_module: whether the given module is an entry module
    Returns:
        ModuleInfo
    """
    if module_name.endswith(tuple(machinery.SOURCE_SUFFIXES)):
        source_module_path = os.path.abspath(module_name)
        fullname = "__main__"
        loader = machinery.SourceFileLoader(fullname, source_module_path)
        spec = util.spec_from_file_location(fullname, source_module_path, loader=loader)
        module = util.module_from_spec(spec)
        spec.loader.exec_module(module)
        module_info = ModuleInfo(fullname, module, is_package(module), source_module_path)
    else:
        try:
            module = create_module(module_name)
        except ModuleNotFoundError as e:
            usage(e.msg)
        if is_package(module) and is_entry_module:
            module_name = f"{module_name}.__main__"
            try:
                module = create_module(module_name)
            except ModuleNotFoundError as e:
                usage(e.msg)
            source_module_path = module.__spec__.origin
        else:
            source_module_path = module.__spec__.origin
        module_info = ModuleInfo(module_name, module, is_package(module), source_module_path)
    return module_info


def get_module_varname(name: str, prefix: str) -> str:
    """
    Get module varname in header file
    Copy from ${CPYTHON_SRC}/Programs/_freeze_module.py
    Args:
        name: module name
        prefix: prefix of the varname
    Returns:
        varname
    """
    return f"{prefix}{name.replace('.', '_')}"


def analyze_module(analysis_info: ModuleAnalysisInfo, module_type: ModuleType) -> dict[str, modulefinder.Module]:
    """
    Get all [module_type] of modules used by [analysis_info]
    Returns:
        All module infos
    """
    hidden_imports = analysis_info.hidden_imports[:]
    excludes = analysis_info.excludes[:]
    is_win = sys.platform.startswith("win")
    if is_win:
        # copy from ${CPYTHON_SRC}/Tools/freeze/freeze.py
        excludes += [
            "dos",
            "dospath",
            "mac",
            "macfs",
            "MACFS",
            "posix",
            "tty",
        ]
    bootstrap_module_names = get_python_bootstrap_module_names()
    # modules that are imported by the Python runtime
    # copy from ${CPYTHON_SRC}/Tools/freeze/freeze.py
    bootstrap_module_names += ["site", "warnings", "encodings.utf_8", "encodings.latin_1"]
    hidden_imports += bootstrap_module_names

    module_info = get_module_info(analysis_info.entry_module_name, is_entry_module=True)
    additional_path = None
    path = sys.path[:]
    for entry in path:
        if not entry.startswith("__editable__"):
            continue
        module_name, _, _ = entry.rpartition(".")
        module_name = module_name.replace(".", "_").replace("-", "_")
        editable_finder_module = importlib.import_module(module_name)
        additional_path = editable_finder_module.MAPPING.get(analysis_info.entry_module_name)
        additional_path = os.path.dirname(additional_path)
    if additional_path is not None:
        path.append(additional_path)
    finder = modulefinder.ModuleFinder(path=path, excludes=excludes)

    for hidden_import_name in hidden_imports:
        finder.import_hook(hidden_import_name)

    finder.run_script(module_info.origin)
    # DEBUG: Uncomment the following line to debug
    # finder.report()
    modules = {}
    for module_name, module in finder.modules.items():
        if module_name in sys.builtin_module_names:
            continue
        if module.__file__.endswith(tuple(machinery.SOURCE_SUFFIXES)) and module_type & ModuleType.SOURCE_MODULE:
            modules[module_name] = module
        if module.__file__.endswith(tuple(machinery.BYTECODE_SUFFIXES)) and module_type & ModuleType.BYTECODE_MODULE:
            modules[module_name] = module
        if module.__file__.endswith(tuple(machinery.EXTENSION_SUFFIXES)) and module_type & ModuleType.EXTENSION_MODULE:
            modules[module_name] = module
    return modules


def get_frozen_module_names(analysis_info: ModuleAnalysisInfo) -> list[str]:
    """
    Get all frozen module names
    Returns:
        All frozen module names
    """
    modules = analyze_module(analysis_info, ModuleType.SOURCE_MODULE)
    module_names = sorted(modules.keys())
    frozen_module_names = []
    for module_name in module_names:
        if module_name in OFFICIAL_FROZEN_MODULE_NAMES:
            continue
        frozen_module_names.append(module_name)
    return frozen_module_names


def print_frozen_header_file_names(entry_module_name: str, hidden_imports_arg: str, excludes_arg: str) -> None:
    """
    Print all frozen header file names for cmake
    Args:
        entry_module: A python module name or a single python_file
        hidden_imports_arg: hidden import modules, e.g. --hidden-imports=xx,yy,aa.bb
        excludes_arg: excludes modules, e.g. --excludes=test,unittest
    Returns:
        None
    """
    hidden_imports = get_list_arg(hidden_imports_arg, "--hidden-imports")
    excludes = get_list_arg(excludes_arg, "--excludes")
    analysis_info = ModuleAnalysisInfo(entry_module_name, hidden_imports, excludes)
    module_names = get_frozen_module_names(analysis_info)
    headers = [FROZEN_MODULES_HEADER.replace("\\", "/")]
    for module_name in module_names:
        header = os.path.join(FROZEN_MODULE_DIR, f"{module_name}.h")
        header = header.replace("\\", "/")
        headers.append(header)
    print(";".join(headers))


def make_freeze(freeze_module_exe: str, entry_module_name: str, hidden_imports_arg: str, excludes_arg: str) -> None:
    """
    Generate all frozen headers for the entry_module_name
    Args:
        entry_module: A python module name or a single python_file
        hidden_imports_arg: hidden import modules, e.g. --hidden-imports=xx,yy,aa.bb
        excludes_arg: excludes modules, e.g. --excludes=test,unittest
    Returns:
        None
    """
    clear_frozen_module_dir()
    hidden_imports = get_list_arg(hidden_imports_arg, "--hidden-imports")
    excludes = get_list_arg(excludes_arg, "--excludes")
    analysis_info = ModuleAnalysisInfo(entry_module_name, hidden_imports, excludes)
    module_names = get_frozen_module_names(analysis_info)
    headers = []
    frozen_structs = []
    for module_name in module_names:
        if module_name == "__main__":
            module_info = get_module_info(entry_module_name, is_entry_module=True)
        else:
            module_info = get_module_info(module_name)
        header_name = f"{module_name}.h"
        header_path = os.path.join(FROZEN_MODULE_DIR, header_name)
        with subprocess.Popen([freeze_module_exe, module_name, module_info.origin, header_path], stderr=subprocess.PIPE) as p:
            p.wait()
            if p.returncode:
                _, err = p.communicate()
                err = str(err, "utf-8")
                usage(err)
        headers.append(f'#include "{header_name}"')
        varname = get_module_varname(module_name, "_Py_M__")
        is_package_literal = "true" if module_info.is_package else "false"
        frozen_struct_literal = f'    {{"{module_name}", {varname}, (int)sizeof({varname}), {is_package_literal}}},'
        frozen_structs.append(frozen_struct_literal)
    headers_literal = "\n".join(headers)
    frozen_structs_literal = "\n".join(frozen_structs)
    frozen_modules_header_src = FROZEN_MODULES_HEADER_SRC.format(frozen_headers=headers_literal, module_infos=frozen_structs_literal)
    with open(FROZEN_MODULES_HEADER, "w", encoding="utf-8") as fp:
        fp.write(frozen_modules_header_src)


def main() -> None:
    """
    Entry point
    Returns:
        None
    """
    options = []

    # option, function, error, description
    options.append(
        (
            "--get-frozen-header-file-names",
            print_frozen_header_file_names,
            "Unable to get frozen header file names.",
            "Print all frozen header file names for cmake.",
        )
    )
    options.append(
        (
            "--make-freeze",
            make_freeze,
            "Unable to locate the Python library for linking.",
            "Generate all frozen headers.",
        )
    )

    option = sys.argv[1]
    for argument, handler, _, _ in options:
        if option != argument:
            continue
        handler(*sys.argv[2:])


def usage(msg: str) -> None:
    """
    Print message and exit
    Args:
        msg: message to show
    Returns:
        None
    """
    print(f"Error: {msg}", file=sys.stderr)
    sys.exit(1)


if __name__ == "__main__":
    main()
